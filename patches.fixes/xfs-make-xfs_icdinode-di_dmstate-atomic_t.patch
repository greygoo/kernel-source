From: Nikolay Borisov <nborisov@suse.com>
Date: Tue, 14 Mar 2017 22:33:41 +0200
Subject: [PATCH] xfs: Make xfs_icdinode->di_dmstate atomic_t
References: bsc#1024788
Patch-mainline: Never, Suse-specific patch

Currently di_dmstate is being used as a counter for the number of holes
punched into a file. In xfs_dm_send_data_event it is being snapshotted i.e.
read under i_iolock. However, a future patch which is going to require
calling xfs_dm_send_data_event without i_iolock held to fix a deadlock
in file splicing. To allow this and at the same time provide the same
snapshot semantics convert di_dmstate to atomic_t.

Acked-by: Nikolay Borisov <nborisov@suse.com>
---
 fs/xfs/dmapi/xfs_dm.c   | 15 ++++++++++-----
 fs/xfs/xfs_inode.c      |  2 +-
 fs/xfs/xfs_inode_buf.c  |  4 ++--
 fs/xfs/xfs_ioctl.c      |  2 +-
 fs/xfs/xfs_itable.c     |  2 +-
 fs/xfs/xfs_log_format.h |  2 +-
 6 files changed, 16 insertions(+), 11 deletions(-)

diff --git a/fs/xfs/dmapi/xfs_dm.c b/fs/xfs/dmapi/xfs_dm.c
index c074e070fe22..1525936e56b7 100644
--- a/fs/xfs/dmapi/xfs_dm.c
+++ b/fs/xfs/dmapi/xfs_dm.c
@@ -148,7 +148,7 @@ xfs_dm_send_data_event(
 	/* Returns positive errors to XFS */
 
 	do {
-		dmstate = ip->i_d.di_dmstate;
+		dmstate = atomic_read(&ip->i_d.di_dmstate);
 		if (lock_flags)
 			xfs_iunlock(ip, *lock_flags);
 
@@ -162,7 +162,7 @@ xfs_dm_send_data_event(
 
 		if (lock_flags)
 			xfs_ilock(ip, *lock_flags);
-	} while (!error && (ip->i_d.di_dmstate != dmstate));
+	} while (!error && (atomic_read(&ip->i_d.di_dmstate) != dmstate));
 
 	return error;
 }
@@ -331,7 +331,7 @@ xfs_ip_to_stat(
 	buf->dt_xfs_extents = dic->di_nextents;
 	buf->dt_xfs_aextents = dic->di_anextents;
 	buf->dt_xfs_igen = dic->di_gen;
-	buf->dt_xfs_dmstate = dic->di_dmstate;
+	buf->dt_xfs_dmstate = atomic_read(&dic->di_dmstate);
 
 	switch (dic->di_format) {
 	case XFS_DINODE_FMT_DEV:
@@ -2284,10 +2284,15 @@ xfs_dm_punch_hole(
 	if (error)
 		error = -error;
 
-	/* Let threads in send_data_event know we punched the file. */
-	ip->i_d.di_dmstate++;
 	xfs_iunlock(ip, XFS_IOLOCK_EXCL);
 
+	/* Let threads in send_data_event know we punched the file.
+	 * Also due to out change from uint16 to effectively uint32, handle
+	 * overflow case manually
+	 */
+	if (!atomic_add_unless(&ip->i_d.di_dmstate, 1, USHRT_MAX)
+			atomic_set(&ip->i_d.di_dmstate, 0); 
+
 up_and_out:
 	up_rw_sems(inode, DM_SEM_FLAG_WR);
 	put_write_access(inode);
diff --git a/fs/xfs/xfs_inode.c b/fs/xfs/xfs_inode.c
index 321009d3664a..ba3daefe38ef 100644
--- a/fs/xfs/xfs_inode.c
+++ b/fs/xfs/xfs_inode.c
@@ -746,7 +746,7 @@ xfs_ialloc(
 	 */
 	ip->i_d.di_extsize = 0;
 	ip->i_d.di_dmevmask = 0;
-	ip->i_d.di_dmstate = 0;
+	atomic_set(&ip->i_d.di_dmstate, 0);
 	ip->i_d.di_flags = 0;
 
 	if (ip->i_d.di_version == 3) {
diff --git a/fs/xfs/xfs_inode_buf.c b/fs/xfs/xfs_inode_buf.c
index e9136de5fd48..de688b7771e6 100644
--- a/fs/xfs/xfs_inode_buf.c
+++ b/fs/xfs/xfs_inode_buf.c
@@ -228,7 +228,7 @@ xfs_dinode_from_disk(
 	to->di_forkoff = from->di_forkoff;
 	to->di_aformat	= from->di_aformat;
 	to->di_dmevmask	= be32_to_cpu(from->di_dmevmask);
-	to->di_dmstate	= be16_to_cpu(from->di_dmstate);
+	atomic_set(&to->di_dmstate, be16_to_cpu(from->di_dmstate));
 	to->di_flags	= be16_to_cpu(from->di_flags);
 	to->di_gen	= be32_to_cpu(from->di_gen);
 
@@ -274,7 +274,7 @@ xfs_dinode_to_disk(
 	to->di_forkoff = from->di_forkoff;
 	to->di_aformat = from->di_aformat;
 	to->di_dmevmask = cpu_to_be32(from->di_dmevmask);
-	to->di_dmstate = cpu_to_be16(from->di_dmstate);
+	to->di_dmstate = cpu_to_be16(atomic_read(&from->di_dmstate));
 	to->di_flags = cpu_to_be16(from->di_flags);
 	to->di_gen = cpu_to_be32(from->di_gen);
 
diff --git a/fs/xfs/xfs_ioctl.c b/fs/xfs/xfs_ioctl.c
index 3d2c9fe3854b..6812947d1245 100644
--- a/fs/xfs/xfs_ioctl.c
+++ b/fs/xfs/xfs_ioctl.c
@@ -373,7 +373,7 @@ xfs_set_dmattrs(
 	xfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);
 
 	ip->i_d.di_dmevmask = evmask;
-	ip->i_d.di_dmstate  = state;
+	atomic_set(&ip->i_d.di_dmstate, state);
 
 	xfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);
 	error = xfs_trans_commit(tp, 0);
diff --git a/fs/xfs/xfs_itable.c b/fs/xfs/xfs_itable.c
index 37613cc3d6cd..b8d947ebf6d2 100644
--- a/fs/xfs/xfs_itable.c
+++ b/fs/xfs/xfs_itable.c
@@ -110,7 +110,7 @@ xfs_bulkstat_one_int(
 	buf->bs_gen = dic->di_gen;
 	memset(buf->bs_pad, 0, sizeof(buf->bs_pad));
 	buf->bs_dmevmask = dic->di_dmevmask;
-	buf->bs_dmstate = dic->di_dmstate;
+	buf->bs_dmstate = atomic_read(&dic->di_dmstate);
 	buf->bs_aextents = dic->di_anextents;
 	buf->bs_forkoff = XFS_IFORK_BOFF(ip);
 
diff --git a/fs/xfs/xfs_log_format.h b/fs/xfs/xfs_log_format.h
index ca7e28a8ed31..1149522781ce 100644
--- a/fs/xfs/xfs_log_format.h
+++ b/fs/xfs/xfs_log_format.h
@@ -559,7 +559,7 @@ typedef struct xfs_icdinode {
 	__uint8_t	di_forkoff;	/* attr fork offs, <<3 for 64b align */
 	__int8_t	di_aformat;	/* format of attr fork's data */
 	__uint32_t	di_dmevmask;	/* DMIG event mask */
-	__uint16_t	di_dmstate;	/* DMIG state info */
+	atomic_t	di_dmstate;	/* DMIG state info */
 	__uint16_t	di_flags;	/* random flags, XFS_DIFLAG_... */
 	__uint32_t	di_gen;		/* generation number */
 
-- 
2.7.4


